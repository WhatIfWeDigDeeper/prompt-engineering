# Module 6 Prompt Patterns III

- [Ask for Input Pattern](#ask-for-input-pattern)
- [Combining Patterns](#combining-patterns)
- [Outline Expansion Pattern](#outline-expansion-pattern)
- [Menu Actions Pattern](#menu-actions-pattern)
- [Fact Check List Pattern](#fact-check-list-pattern)
- [Tail Generation Pattern](#tail-generation-pattern)
- [Semantic Filter Pattern](#semantic-filter-pattern)
- [Conclusion](#conclusion)
- [Exercise](#exercise)
	- [Exercise Prompt](#exercise-prompt)
- [Would you like to dive deeper into any specific aspect of this approach or move to another prompt?](#would-you-like-to-dive-deeper-into-any-specific-aspect-of-this-approach-or-move-to-another-prompt)
- [Would you like further details about iframe-specific communication, styling, or performance optimization? Or should we move to another task?](#would-you-like-further-details-about-iframe-specific-communication-styling-or-performance-optimization-or-should-we-move-to-another-task)


## Ask for Input Pattern

Example

Combines asking ChatGPT to come up with alternative prompts and the ask for input pattern.

```text
Whenever I ask you to write a prompt for me to accomplish a task,
list what the task is,
list alternative approaches for completing the task,
and then write a prompt for yourself for each approach.
When you are done,
ask me for the next prompt to create alternatives for.

Ask me for the first task.
```

## Combining Patterns

What pattern would solve certain aspects of the problem and how to combine those patterns together.

> At the end of the day you are still describing in words what you want done

## Outline Expansion Pattern

To use this pattern, your prompt should make the following fundamental contextual statements:

```text
# Persona Pattern
Act as an outline expander.
Generate a bullet point outline
based on the input that I give you
and then ask me for which bullet point you should expand on.
Create a new outline for the bullet point that I select.

# Tail Generation Pattern
At the end, ask me for what bullet point to expand next .

# Ask for Input pattern
Ask me for what to outline.
```

Similar Example with formatting

```text
Act as an outline expander.
Generate a bullet point outline
 based on the input that I give you
 and then ask me for which bullet point
 you should expand on.
Each bullet can have at most 3-5 sub bullets.
The bullets should be numbered using the pattern
[A-Z].[i-v].[* through ****]

Create a new outline
 for the bullet point that I select.
At the end,
 ask me for what bullet point to expand next.

Ask me for what to outline.
```

## Menu Actions Pattern

```text
Whenever I type: "write <bullet point> <paragraphs>",
 you will write content
 for the selected bullet point <bullet point>.
You will write <paragraphs> of text.
Whenever I type just "<bullet point>"
 you'll expand that bullet point.

At the end you will ask me for the next action.
```

Example

```text
Whenever I type: "add FOOD",
 you will add FOOD to my grocery list
 and update my estimated grocery bill.

Whenever I type "remove FOOD",
 you will remove FOOD from my grocery list
 and update my estimated grocery bill.

Whenever I type "save",
 you will list alternatives
 to my added FOOD to save money.

At the end,
 you will ask me for the next action.

Ask me for the first action.
```

## Fact Check List Pattern

Example

```text
Whenever you output text,
 generate a set of facts
 that are contained in the output.
The set of facts should be inserted
 at the end of the output.
The set of facts should be the fundamental facts
 that could undermine the veracity of the output
 if any of them are incorrect.
```

## Tail Generation Pattern

Reminds the LLM with the rules we've set as sometimes they lose track.

* At the end, repeat Y and/or ask me for X.

Example

```text
From now on, at the end of your output, add the disclaimer

This output was generated by a large language model.
It may contain errors or inaccurate statements.
All statements should be fact checked.

Ask me for the first thing to write about.
```

## Semantic Filter Pattern

* Filter this information to remove X

Examples

```text
Filter this information
 to remove any personally identifying information
 or information that could potentially be used
 to re-identify the person.
```

```text
Filter this email to remove redundant information.
```

## Conclusion

Creativity to use the tool. A medium for creativity like paint or sculpture.

Practice, practice, practice.

Keep up with research

[ChatGPT Prompt Patterns for Improving Code Quality, Refactoring, Requirements Elicitation, and Software Design](https://arxiv.org/abs/2303.07839)

## Exercise

Develop your own prompt-based application, similar to the outlining application from the videos, to help you accomplish a task. Your application can do whatever you want and does not have to be focused on outlining. Come up with a creative way of using large language models to program an environment to solve a problem you face on a daily basis.

Provide your prompt and a sample of using the prompt-based application.

### Exercise Prompt

```text
Whenever I say "act as a <persona>: <task>",
 in addition to answering any prompt with the format

* list what the task is
* write a summary of the approach
* write the details
* list a short description of alternative approaches
  for completing the task in an alphabetical list

I want you to add a section at the end.

* write alternative better prompts in a numbered list
  that include the pattern name.
	These can be a combination of patterns.

When you are done, ask me for the next prompt.
If I enter a <number>
 provide more details
 of the alternative approach
 from the numbered list.
If I enter a single letter,
 execute the alternative prompt to yourself
 from the alphabetical list.

Ask me for the first task.
```

<details>
<summary>Responses</summary>

Understood! Please provide the first task.

---

```text
act as a software engineer:
I want to slowly migrate a UI
 written in Javascript and React
 to another repository
 written in Typescript and React
 and served from the same domain.

What are the approaches I can use to accomplish this?
```

---

What the Task Is

To determine approaches for gradually migrating a UI written in JavaScript and React to another repository using TypeScript and React, ensuring both are served from the same domain.

Summary of the Approach

A gradual migration involves identifying independent components or pages to migrate, setting up communication between the repositories, and ensuring seamless user experience by serving both versions concurrently.

Details
	1.	Preparation
	•	Analyze the current codebase and identify independent components or modules.
	•	Set up the new repository with TypeScript and React configurations.
	2.	Serve from the Same Domain
	•	Use a reverse proxy (e.g., Nginx or Apache) to route requests to either repository based on URL patterns.
	•	Alternatively, configure your React build scripts to output files to the same static directory.
	3.	Communication Between Repositories
	•	Use a shared state management library like Redux or Context API if required.
	•	Employ cross-origin messaging for inter-repo communication if both UIs share runtime data.
	4.	Incremental Migration
	•	Start with a non-critical feature or page, migrating it fully to the TypeScript repository.
	•	Test thoroughly for regressions or inconsistencies.
	5.	Deprecate the Old Repository
	•	As features/pages are fully migrated, disable their counterparts in the JavaScript repository.
	•	Once migration is complete, decommission the old repository.

Alternative Approaches

A. Iframe-Based Migration
Use iframes to embed pages from the TypeScript repository into the existing JavaScript app during the transition.

B. Micro-Frontend Architecture
Divide the app into independent frontends managed by a single container.

C. Feature Flagging
Use feature flags to toggle between old and new implementations seamlessly.

D. Codebase Duplication with Merged Deployment
Duplicate the codebase and incrementally refactor to TypeScript while deploying a merged build.

Alternative Better Prompts
	1.	Stepwise Migration Plan Pattern
“How can I create a stepwise migration plan to move a React-based UI from JavaScript to TypeScript across repositories while minimizing downtime?”
	2.	Micro-Frontend Integration Pattern
“What are the best practices for using a micro-frontend architecture to gradually migrate a React app to a new TypeScript repository?”
	3.	Cross-Domain Communication Pattern
“How can I set up communication between two React apps hosted in different repositories during a gradual migration process?”
	4.	Proxy Routing and Deployment Pattern
“How can I configure a reverse proxy to serve two React repositories from the same domain during a UI migration?”
	5.	Refactoring and Testing Pattern
“What strategies can I use to refactor and test a JavaScript-based React app as I migrate it to TypeScript in a new repository?”

What’s the next prompt? Enter a number for more details on an alternative approach or a letter to execute the corresponding approach.

---
```text
Alternative Approach 2
```
---
Details for Alternative Approach 2: Micro-Frontend Integration Pattern

What It Is:
Micro-frontend architecture allows breaking a monolithic UI into smaller, independently deployable units. During the migration, each frontend can be hosted in separate repositories, enabling gradual transition without disrupting the user experience.

Steps for Using Micro-Frontend Architecture
	1.	Choose a Micro-Frontend Framework
	•	Select a framework such as Module Federation (Webpack 5), Single-SPA, or Qiankun to orchestrate multiple frontends.
	•	Ensure the framework supports React and TypeScript seamlessly.
	2.	Define Application Boundaries
	•	Identify logical boundaries in the UI (e.g., features, pages, or modules) to split into micro-frontends.
	•	Each micro-frontend should function independently while integrating smoothly with others.
	3.	Set Up the New TypeScript Repository
	•	Configure the new repository as a micro-frontend with the necessary tooling and dependencies.
	•	Implement TypeScript-specific settings like strict type checking and type declarations.
	4.	Integrate with the Existing JavaScript Repository
	•	Modify the current JavaScript app to act as the container for micro-frontends.
	•	Dynamically load the TypeScript-based micro-frontend using Module Federation or another solution.
	5.	Serve from the Same Domain
	•	Use a reverse proxy to map requests to the appropriate micro-frontend based on URL patterns.
	•	Alternatively, host both frontends on the same static server with path-based routing.
	6.	Incremental Migration
	•	Begin by migrating a single module or feature.
	•	Deploy and test each micro-frontend independently before integrating it into the container app.
	7.	Optimize Shared Resources
	•	Use shared dependencies to reduce redundancy (e.g., React and utility libraries).
	•	Implement caching for shared assets to improve performance.
	8.	Complete the Migration
	•	Gradually replace all JavaScript-based features with their TypeScript counterparts.
	•	Decommission the old repository when all features are migrated.

Advantages of Micro-Frontend Integration
	•	Enables independent development and deployment.
	•	Reduces the risk of large-scale regressions.
	•	Improves scalability and modularity.

Challenges
	•	Increased complexity in managing shared resources and communication.
	•	Requires careful coordination during deployment and testing.

Would you like to dive deeper into any specific aspect of this approach or move to another prompt?
---
```text
A
```
---
Executing Approach A: Iframe-Based Migration

What It Is:
Using iframes, you can embed the new TypeScript-based UI (hosted separately) into the existing JavaScript-based React app. This allows you to serve both UIs concurrently during the migration.

Steps for Iframe-Based Migration
	1.	Set Up the TypeScript Repository
	•	Configure the new repository to host the TypeScript-based React UI.
	•	Ensure it can run independently and is accessible via a specific URL or subpath.
	2.	Embed the Iframe in the JavaScript App
	•	Add an iframe component to the JavaScript-based React app where the new UI should appear.
	•	Set the src of the iframe to point to the hosted TypeScript-based app.
Example:

```Javascript
const NewFeatureIframe = () => (
  <iframe
    src="https://your-domain.com/new-feature"
    title="New Feature"
    style={{ width: '100%', height: '100%', border: 'none' }}
  />
);
```

	3.	Set Up Communication
	•	Use the postMessage API for communication between the parent app and the iframe.
	•	Ensure secure messaging by validating the origin of incoming messages.
Example: Sending a message:

iframeRef.current.contentWindow.postMessage({ type: 'UPDATE_DATA', payload: data }, 'https://your-domain.com');

Example: Receiving a message:

```JavaScript
window.addEventListener('message', (event) => {
  if (event.origin !== 'https://your-domain.com') return;
  // Handle the message
});
```

	4.	Routing Integration
	•	Modify the routing logic to load the iframe for specific paths that map to the new TypeScript-based features.
	5.	Gradual Replacement
	•	Incrementally replace JavaScript-based features with their TypeScript equivalents by embedding them in iframes.
	•	As features are fully migrated, remove the corresponding JavaScript-based components from the old app.
	6.	Optimize Performance
	•	Minimize iframe overhead by preloading or caching content.
	•	Ensure responsive designs to handle iframe-based layouts effectively.

Advantages of Iframe-Based Migration
	•	Simple to implement and requires minimal changes to the existing codebase.
	•	Provides clear isolation between the old and new codebases.

Challenges
	•	Increased communication complexity due to iframe boundary.
	•	Potential performance issues with heavy iframe usage.
	•	Styling inconsistencies between the parent app and iframe content.

Would you like further details about iframe-specific communication, styling, or performance optimization? Or should we move to another task?
---
```text
act as a software architect: provide a recommendation for which approach to choose
```
---
What the Task Is

Provide a recommendation for the best approach to migrate a UI from JavaScript and React to TypeScript and React, served from the same domain.

Summary of the Recommendation

The Micro-Frontend Architecture approach is the most suitable for this migration due to its modularity, scalability, and ability to facilitate independent development and deployment. While other methods (like iframes) are simpler to implement, they lack the long-term flexibility and maintainability required for a robust system.

Details

Why Micro-Frontend Architecture?
	1.	Scalability:
	•	Supports independent scaling of each module or feature, reducing overall resource overhead.
	•	Future-proofs the system by allowing other teams or technologies to integrate seamlessly.
	2.	Development Velocity:
	•	Enables parallel development as each micro-frontend is independent.
	•	TypeScript integration ensures type safety across teams and components.
	3.	Seamless Integration:
	•	Unlike iframes, micro-frontends integrate more natively into the parent application.
	•	Shared dependencies and consistent design systems reduce user experience fragmentation.
	4.	Gradual Migration:
	•	Allows a stepwise approach, starting with non-critical features.
	•	Minimizes disruption to the existing app and end-users.

How to Implement the Recommendation
	1.	Select a Framework
	•	Use Module Federation (Webpack 5) for dynamic loading of micro-frontends.
	2.	Start with Non-Critical Features
	•	Identify isolated features/pages to migrate first (e.g., settings or help pages).
	3.	Shared State Management
	•	Use a shared library for global state (e.g., Redux, Context API) to ensure data consistency.
	4.	Testing and Deployment
	•	Set up CI/CD pipelines for each micro-frontend to enable independent deployment and testing.
	5.	Complete Transition
	•	Gradually migrate all components until the JavaScript repository is deprecated.

Alternative Approaches (With Recommendations)

A. Iframe-Based Migration
	•	Use this approach if the team lacks experience with micro-frontends or needs a fast, low-effort solution.
	•	Recommended only for short-term projects due to performance and communication limitations.

B. Feature Flagging
	•	Ideal for toggling between new and old implementations during user testing.
	•	Combine with the micro-frontend approach for maximum flexibility.

C. Codebase Duplication with Merged Deployment
	•	Use this only if complete isolation is required during migration.
	•	Higher overhead makes it less ideal for long-term maintainability.

Alternative Better Prompts
	1.	Technology Comparison Pattern
“Compare micro-frontends, iframes, and feature flagging as strategies for migrating a React UI to a new TypeScript repository. Which is the best for scalability?”
	2.	Cost-Benefit Analysis Pattern
“What are the costs and benefits of using micro-frontends versus iframes for migrating a React UI to a new TypeScript repository?”
	3.	Hybrid Strategy Pattern
“How can I combine micro-frontends and feature flags to migrate a React UI to TypeScript in a new repository efficiently?”
	4.	Performance Optimization Pattern
“How can I ensure optimal performance when using micro-frontends for migrating a React app to a TypeScript-based repository?”
	5.	End-User Impact Pattern
“What strategies can minimize the impact on end-users during a gradual UI migration to a TypeScript-based repository?”

Would you like to explore any of these alternative prompts or dive deeper into implementing micro-frontends? Enter a number for more details or a letter for another approach!
</details>

[previous](./module5.md) | [top](#module-6-prompt-patterns-iii) | [course](./readme.md)
